<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>THYP 25-26 — Projets (depuis Google Sheets)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Bootstrap (styles rapides) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <link rel="stylesheet" href="styles.css">
  <!-- D3 pour lire le CSV simplement -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  
</head>
<body>
  <div class="container py-4">
    <header class="mb-3">
      <h1 class="h3 mb-1">THYP 25-26 — Projets</h1>
      <div class="text-muted">Source : Google Sheets (mise à jour automatique quand le formulaire reçoit des réponses)</div>
    </header>

    <!-- Barre outils -->
    <div class="searchbar">
      <div class="row g-2 align-items-center">
        <div class="col-12 col-md-6">
          <input id="q" class="form-control form-control-lg" placeholder="Rechercher (titre, résumé, objectifs, techno…)" />
        </div>
        <div class="col-6 col-md-3">
          <select id="keySelect" class="form-select">
            <option value="">— Filtrer par colonne —</option>
          </select>
        </div>
        <div class="col-6 col-md-3 text-md-end">
          <a id="downloadCsv" class="btn btn-outline-primary" target="_blank" rel="noopener">Télécharger le CSV</a>
        </div>
      </div>
    </div>

    <!-- Résumé -->
    <div class="mt-3 mb-2">
      <span id="count" class="muted">Chargement…</span>
    </div>

    <!-- Grille cartes -->
    <div id="grid" class="grid"></div>

    <p class="footer-note mt-4 muted">
      Astuce : ce gabarit s’adapte automatiquement aux intitulés de questions de ton formulaire (il n’exige pas des noms de colonnes précis).
    </p>
  </div>

  <script>
  (function(){
    // === 1) CONFIG ===
    const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vREH0YrVGx0VyRdsIamPOa4NWriyGPgDFFbpRcR5vwRdVtaU8SV4TxhU6yHDYswrlwHh3BKp8BkxHyY/pub?output=csv";

    // Indices/alias probables pour mieux titrer les cartes (si présents)
    const TITLE_HINTS = [
      "Titre du projet","Titre","Project title","Nom du projet"
    ];
    const SUMMARY_HINTS = [
      "Résumé","Résumé du projet","Description","Pitch","Synthèse"
    ];

    // Groupes (affichage structuré si on reconnaît ces colonnes)
    const GROUPS = {
      "Contenu & objectifs": [
        "Objectifs","Objectifs principaux du projet","Problématique","Problématique / besoin",
        "Public cible","Audience","Cible"
      ],
      "Aspects techniques": [
        "Technologies envisagées","Technologies","Type de médias intégrés","Médias",
        "Fonctionnalités prévues","Fonctionnalités"
      ],
      "Références": [
        "Liens utiles","Liens","URL","Références","Ressources prévues","Ressources"
      ]
    };

    // === 2) ÉTAT ===
    let RAW = [];
    let FILTERED = [];
    let ALL_KEYS = [];

    // === 3) OUTILS ===
    const norm = s => (s||"").toString().trim();
    const lc = s => norm(s).toLowerCase();

    function pickFirstKey(obj, hints){
      for(const h of hints){
        const k = Object.keys(obj).find(k => lc(k) === lc(h));
        if(k) return k;
      }
      // fallback: rien trouvé
      return null;
    }

    function splitMulti(val){
      // Gère cases à cocher (souvent CSV = "A, B, C")
      if(!val) return [];
      // Sépare par ; ou , (selon paramétrage de Google Sheets)
      return val.split(/[,;]\s*/).map(v => v.trim()).filter(Boolean);
    }

    function buildCard(row){
      // 1) Titre + résumé (si colonnes devinées)
      const titleKey = pickFirstKey(row, TITLE_HINTS);
      const sumKey   = pickFirstKey(row, SUMMARY_HINTS);
      const title = norm(row[titleKey]) || "Projet sans titre";
      const summary = norm(row[sumKey]) || "";

      // 2) Préparer sections par groupe
      const sections = [];

      for(const [label, columns] of Object.entries(GROUPS)){
        const present = columns
          .map(colName => {
            const k = Object.keys(row).find(k => lc(k) === lc(colName));
            return k || null;
          })
          .filter(Boolean);

        if(present.length){
          const items = present.map(k => {
            const v = norm(row[k]);
            if(!v) return null;

            // Affichage intelligent : si liste, présenter en "pills"
            const parts = splitMulti(v);
            if(parts.length > 1){
              const pills = parts.map(x => `<span class="pill">${escapeHtml(x)}</span>`).join(" ");
              return `<div class="mb-2"><div class="key">${escapeHtml(k)}</div><div>${pills}</div></div>`;
            }
            // URL auto-liées
            if(isLikelyUrl(v)){
              return `<div class="mb-2"><div class="key">${escapeHtml(k)}</div><div><a href="${escapeUrl(v)}" target="_blank" rel="noopener">${escapeHtml(v)}</a></div></div>`;
            }
            // Paragraphe simple
            return `<div class="mb-2"><div class="key">${escapeHtml(k)}</div><div>${escapeHtml(v)}</div></div>`;
          }).filter(Boolean);

          if(items.length){
            sections.push(`
              <div class="mb-2">
                <div class="muted fw-semibold mb-1">${label}</div>
                ${items.join("")}
              </div>
            `);
          }
        }
      }

      // 3) Colonnes non classées (pour ne rien perdre)
      const groupedKeys = new Set(
        [].concat(...Object.values(GROUPS)).map(x => lc(x))
      );
      if(titleKey) groupedKeys.add(lc(titleKey));
      if(sumKey) groupedKeys.add(lc(sumKey));

      const misc = Object.keys(row)
        .filter(k => lc(k) && !groupedKeys.has(lc(k)) && norm(row[k]))
        .filter(k => lc(k) !== "timestamp" && lc(k) !== "horodatage")
        .map(k => {
          const v = norm(row[k]);
          const parts = splitMulti(v);
          if(parts.length > 1){
            const pills = parts.map(x => `<span class="pill">${escapeHtml(x)}</span>`).join(" ");
            return `<span class="badge bg-light text-dark badge-kv"><span class="key">${escapeHtml(k)}:</span> ${pills}</span>`;
          }
          if(isLikelyUrl(v)){
            return `<span class="badge bg-light text-dark badge-kv"><span class="key">${escapeHtml(k)}:</span> <a href="${escapeUrl(v)}" target="_blank" rel="noopener">${escapeHtml(v)}</a></span>`;
          }
          return `<span class="badge bg-light text-dark badge-kv"><span class="key">${escapeHtml(k)}:</span> ${escapeHtml(v)}</span>`;
        });

      // 4) HTML carte
      return `
        <div class="card h-100">
          <div class="card-body">
            <h5 class="card-title mb-1">${escapeHtml(title)}</h5>
            ${summary ? `<p class="card-text">${escapeHtml(summary)}</p>` : ``}
            ${sections.join("")}
            ${misc.length ? `<div class="mt-2">${misc.join(" ")}</div>` : ``}
          </div>
        </div>
      `;
    }

    function render(){
      const grid = d3.select("#grid");
      grid.html("");

      if(!FILTERED.length){
        d3.select("#count").text("Aucun résultat.");
        return;
      }

      d3.select("#count").text(`${FILTERED.length} projet(s)`);

      grid.selectAll(".col")
        .data(FILTERED)
        .enter()
        .append("div")
        .attr("class","col")
        .html(d => buildCard(d));
    }

    function isLikelyUrl(s){
      return /^https?:\/\/|^www\./i.test(s);
    }

    function escapeHtml(s){
      return s
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;")
        .replace(/'/g,"&#39;");
    }

    function escapeUrl(s){
      try { return new URL(s).toString(); }
      catch { return s; }
    }

    function searchFilter(q, key){
      const qlc = lc(q);
      return RAW.filter(row => {
        // Filtre par colonne spécifique si choisi
        if(key){
          const val = row[key] ?? "";
          return lc(val).includes(qlc);
        }
        // Sinon, recherche plein texte sur toutes les colonnes
        return Object.values(row).some(v => lc(v).includes(qlc));
      });
    }

    function populateKeySelect(){
      const sel = document.getElementById("keySelect");
      sel.innerHTML = `<option value="">— Filtrer par colonne —</option>`;
      ALL_KEYS.forEach(k => {
        const opt = document.createElement("option");
        opt.value = k;
        opt.textContent = k;
        sel.appendChild(opt);
      });
    }

    // === 4) INIT ===
    document.getElementById("downloadCsv").href = CSV_URL;

    d3.csv(CSV_URL).then(rows => {
      RAW = rows.map(r => {
        // Trim de toutes les valeurs
        const o = {};
        Object.keys(r).forEach(k => { o[k.trim()] = (r[k] ?? "").toString().trim(); });
        return o;
      });

      // Collecte des clés (colonnes)
      const keySet = new Set();
      RAW.forEach(r => Object.keys(r).forEach(k => keySet.add(k)));
      ALL_KEYS = Array.from(keySet);

      populateKeySelect();

      FILTERED = RAW.slice();
      render();
    }).catch(err => {
      console.error(err);
      d3.select("#count").text("Erreur de chargement du CSV. Vérifie que la feuille est bien publiée en CSV.");
    });

    // === 5) ÉCOUTEURS ===
    const qInput = document.getElementById("q");
    const keySel = document.getElementById("keySelect");

    function applyFilters(){
      const q = qInput.value || "";
      const key = keySel.value || "";
      FILTERED = searchFilter(q, key);
      render();
    }

    qInput.addEventListener("input", applyFilters);
    keySel.addEventListener("change", applyFilters);
  })();
  </script>
</body>
</html>
